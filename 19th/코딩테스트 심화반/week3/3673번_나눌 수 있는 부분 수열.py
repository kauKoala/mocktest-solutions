for _ in range(int(input())):
    d, n = map(int, input().split())
    arr = list(map(int, input().split()))
    
    # arr 리스트의 0번째 원소부터 현재 원소까지의 합을 d로 나눈 나머지를 sum_arr에 저장한다. (sum이 너무 커지는 것을 방지)
    sum_arr = [arr[0] % d]
    for i in range(1, n):
        sum_arr.append((sum_arr[-1] + arr[i]) % d)

    # 같은 값을 가진 두 나머지가 있을 경우, 그 사이의 합은 d로 나누어 떨어진다. (예시 참고)
    # 같은 값을 가진 나머지가 n개일 경우 그 중 두 개(부분 수열의 시작점, 끝점)를 선택하면 되기에 조합(nC2)을 사용한다.
    # ex 1) 
    # d = 3이고, {1 4 2} 수열이 있을 경우
    # 초깃값 0부터 시작하여 0 1 2 1 순서로 저장된다. 
    # 첫 번째 숫자는 초깃값 0, 두 번째 숫자는 (0 + 1) % 3 = 1, 세 번째 숫자는 (1 + 4) % 3 = 2, 네 번째 숫자는 (2 + 2) % 3 = 1
    # 1이라는 나머지가 두 번 나왔기에 그 사이에는 3으로 나누어 떨어지는 부분 수열(2~3)이 1개(2C2) 존재한다.
    # ex 2)
    # d = 3이고, {1 1 1} 수열이 있을 경우
    # 초깃값 0부터 시작하여 0 1 2 0 순서로 저장된다.
    # 첫 번째 숫자는 초깃값 0, 두 번째 숫자는 (0 + 1) % 3 = 1, 세 번째 숫자는 (1 + 1) % 3 = 2, 네 번째 숫자는 (2 + 1) % 3 = 0
    # 0이라는 나머지가 두 번 나왔기에 그 사이에는 3으로 나누어 떨어지는 부분 수열(1~3)이 1개(2C2) 존재한다.
    # ex 3) 
    # d = 3이고, {1 3 3} 수열이 있을 경우
    # 초깃값 0부터 시작하여 0 1 1 1 순서로 저장된다.
    # 첫 번째 숫자는 초깃값 0, 두 번째 숫자는 (0 + 1) % 3 = 1, 세 번째 숫자는 (1 + 3) % 3 = 1, 네 번째 숫자는 (1 + 3) % 3 = 1
    # 1이라는 나머지가 세 번 나왔기에 그 사이에는 3으로 나누어 떨어지는 부분 수열 {2~2}, {2~3}, {3~3}이 3개(3C2) 존재한다.

    count_arr = [0] * 1000001
    count_arr[0] += 1
    for i in sum_arr:  # 같은 나머지의 개수를 저장한다.
        count_arr[i] += 1
    
    result = 0
    for i in count_arr:
        if i >= 2:  # count_arr의 원소가 2이상일 경우 부분 수열의 양 끝 점이 될 수 있으므로 nC2를 계산해 결과(result)에 더한다.
            result += ((i * (i - 1)) // 2)
    
    print(result)