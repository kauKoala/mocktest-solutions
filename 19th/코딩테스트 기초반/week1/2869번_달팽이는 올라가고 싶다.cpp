#include <iostream>

using namespace std;

// 문제를 두 가지 방법으로 풀 수 있다.
// 1. 반복문을 이용해서 꼭대기에 도달할 때 까지 A미터 올라갔다가 B미터 내려갔다가 반복
// 2. 나눗셈을 이용

// 1번으로 풀 경우 시간 초과가 날 것이다.
// 그 이유는 1초에 약 1억번의 계산을 할 수 있는데 문제에서는 0.25초의 시간이 주어졌다.
// V가 최댓값인 10억이고, A와 B가 1만 차이날 경우 약 10억번의 계산이 필요하여 시간 초과가 난다. 
// 2번의 경우 한 번의 계산으로 답을 구할 수 있다.

int main() {
    int A, B, V;    
    cin >> A >> B >> V;
    
    // 정답을 0으로 초기화한다.
    int ans = 0;
    
    // 꼭대기에서부터 역으로 내려간다. 맨 마지막에는 미끄러지지 않고 올라간 후 종료이므로, 올라간 만큼 빼준다.
    V -= A; // V = V - A와 같음
    // A만큼 미리 올라갔다고 생각한다.
    ans++; // ans = ans + 1과 같음
    
    // V를 A - B로 나누어 A - B가 V에 들어갈 수 있는 만큼 ans에 더해준다.
    // c++에서 나눗셈은 나누어 떨어지지 않을 경우 내림 처리를 한다.
    ans += V / (A - B);
    
    // 만약 V가 정확하게 나누어 떨어지지 않을 경우, 한 번 더 올라가야만 나무 막대를 모두 올라갈 수 있다.
    if (V % (A - B) > 0) ans++;
    
    cout << ans;
    
    return 0;
}